# 3️⃣ 複雜度 Complexity

複雜度分成時間跟空間兩種

## 時間複雜度

一般而言我們用**約略的運算執行次數**來計算時間複雜度，以 T\(n\) 表示程式執行了多少指令，n 通常為輸入大小。

比如說以下幾段程式

```python
print("Hey!")
```

執行 1 次指令，T\(n\) = 1，跟 n 沒有關係。

```python
n = int(input())
for i in range(n):
    print(i)
```

執行 n 次指令，T\(n\) = n

```python
n = int(input())
for i in range(n):
    for j in range(n):
        print(i, j)
```

執行 n^2 次指令，T\(n\) = n^2

```python
n = int(input())
for i in range(n):
    print(i)
    for j in range(n):
        print(j) 
```

執行 n^2 + n 次指令，T\(n\) = n^2 + n

```python
n = int(input())
for i in range(n):
    print(i)
    for j in range(n):
        print(j)
        print(j) 
```

執行 2\*n^2 + n 次指令，T\(n\) = 2\*n^2 + n

![T\(n\) = 1  &#xFF0C;T\(n\) = n&#xFF0C;T\(n\) = n^2 &#x7684;&#x6BD4;&#x8F03;&#xFF0C;&#x53EF;&#x4EE5;&#x5F88;&#x6E05;&#x695A;&#x7684;&#x770B;&#x5230;&#x6210;&#x9577;&#x5DEE;&#x7570;&#xFF0C;&#x7576; n &#x5F88;&#x5927;&#x7684;&#x6642;&#x5019;&#x6240;&#x82B1;&#x7684;&#x6642;&#x9593;&#x76F8;&#x5C0D;&#x591A;&#x5F88;&#x591A;&#xFF0C;&#x53EF;&#x4EE5;&#x8A66;&#x8457;&#x7528; Geogebra &#x7B49;&#x7E6A;&#x5716;&#x7A0B;&#x5F0F;&#x756B;&#x756B;&#x770B;](../../.gitbook/assets/image%20%288%29.png)

#### 為什麼不直接估計時間?

執行時間受系統、狀態等諸多因素影響，因此同一個程式在不同環境的執行時間皆可能不同，因此難以估計，更不可能找到適用所有環境的通式，比如超級電腦和個人電腦的執行時間一定不一樣。

#### 為什麼不精準計算運算執行次數? <a id="&#x70BA;&#x4EC0;&#x9EBC;&#x4E0D;&#x7CBE;&#x6E96;&#x8A08;&#x7B97;&#x904B;&#x7B97;&#x57F7;&#x884C;&#x6B21;&#x6578;"></a>

* 難以計算
* 受編譯器（優化）影響而有所不同
* 即使是同樣的演算法，在各種情況，執行的指令數量多少會有些不同

### 大O符號 Big O Notation：用來描述時間複雜度的方法

T\(n\) 在大規模數據的情況下，也就是當 n 足夠大的時候，有些差異不是那麼明顯或重要，因此改用**大O符號 Big O Notation** 來粗略比較、分類。若將上述四段程式寫成大O符號：

1. T\(n\) = 1 = O\(1\)
2. T\(n\) = n = O\(n\)
3. **T\(n\) = n^2 = O\(n^2\)**
4. **T\(n\) = n^2 + n = O\(n^2\)**
5. **T\(n\) = 2\*n^2 + n = O\(n^2\)**

注意 3、4、5 點，除了最高階項之外都被省略掉了，而且常數也去掉了，想想看原因為何？

![  3&#x3001;4&#x3001;5 &#x9EDE;&#x5728;&#x5C0F;&#x898F;&#x6A21;&#x60C5;&#x6CC1;&#x4E0B;&#x7684;&#x4F5C;&#x5716;](../../.gitbook/assets/image%20%283%29.png)

####  大O符號有以下兩個特點：

* 僅保留最高階項
* 省略常數（係數）

#### 僅保留最高階項 <a id="&#x70BA;&#x4EC0;&#x9EBC;&#x50C5;&#x4FDD;&#x7559;&#x6700;&#x9AD8;&#x968E;&#x9805;"></a>

當 n 足夠大時，最高階項以外的項影響很小可以忽略，因此只保留最高階項即可，例如

$$
n^2+n\\ when\ n > 10^5, \ n^2>>n\\ =>n^2+n\approx n^2
$$

#### 省略常數（係數） <a id="&#x70BA;&#x751A;&#x9EBC;&#x8981;&#x7701;&#x7565;&#x5E38;&#x6578;"></a>

假設有兩個程式：

$$
T(n) = n^3\\
U(n) = 10000n^2
$$

當 n &lt; 10000 時，T\(n\) &lt; U\(n\)，但

當 n &gt; 10000 後，T\(n\) &gt; U\(n\)，我們在意大規模數據下的情況，因此常數就不是那麼重要了。

### 計算實例 <a id="&#x6642;&#x9593;&#x8907;&#x96DC;&#x5EA6;&#x7684;&#x61C9;&#x7528;"></a>

#### 迴圈的時間複雜度 <a id="&#x8FF4;&#x5708;&#x7684;&#x6642;&#x9593;&#x8907;&#x96DC;&#x5EA6;"></a>

迴圈的執行次數 \* 每次迴圈的時間複雜度

```python
for i in range(n):
    l[i] = a*l[i-1] + b
    a, b = b, a
```

很明顯 O\(n\)

```python
for i in range(n):
    for j in range(i+1, n):
        if l[i] > l[j]:
           l[i], l[j] = l[j], l[i]
```

執行次數大約是

$$
(n−1)+(n−2)+...+1+0\\
=\frac{n(n−1)}{2}\\
=\frac{1}{2}n^2-\frac{1}{2}n
$$

  
因此時間複雜度是 $$O(n^2) $$

```python
sum = 0
i = 1
while i < n:
  sum += i
  i *= 2
```

$$
2^i<n⇒i<log(n)
$$

因此是 $$O(log(n))$$

log若沒有特別註明，通常是以 2 為底，也就是 $$log_2n$$ 

### 應用 <a id="&#x6642;&#x9593;&#x8907;&#x96DC;&#x5EA6;&#x7684;&#x61C9;&#x7528;"></a>

#### **判斷一個程式會不會** **TLE（執行逾時）**

當你想到一個做法後，在開始寫之前就能先用時間複雜度來判斷是否會 TLE**（**或者對於有部分給分的題目，判斷能拿多少分）以避免浪費時間在寫必然會 TLE 的程式，在實作中更容易作時間分配。如果對複雜度的信仰夠深，且題目水準夠高，可以用複雜度反推來猜演算法。

#### 詳細算法

1. 把時間複雜度的大O符號拿掉，並將題目給定的輸入範圍**上限**帶入函數，令得到的數值為 $$ T$$
2. 一般而言假設程式每秒能跑 $$10^8$$ 
3. 假設題目的時限是 $$TL$$  秒，那麼
   * 若 $$ T<TL×10^8$$則通常不會 TLE
   * 若 $$T>TL×5×10^8$$ 則極有可能拿到 TLE

例如:

| O\(n\) | n | T | TL | 很可能 TLE |
| :--- | :--- | :--- | :--- | :--- |
| $$O(n^2)$$  | $$n\le 5000$$ | $$2.5*10^7$$  | TL=1 | X |
|  $$O(n^3)$$  | $$n\le 1000$$ | $$   10^9 $$  | TL=1 | O |
|  $$O(nlog^2(n))$$  | $$n\le10^5$$ | $$2.75* 10^7 $$ | TL=1 | X |
| $$O(nlog(n))$$ | $$n\le10^6$$ | $$  2* 10^7 $$ | TL=1 | X |
| $$O(n\sqrt n) $$  | $$n\le10^6$$ | $$   10^9 $$ | TL=1 | O |
|  $$O(n2^n)$$  | $$n\le20$$ | $$   2*10^7 $$ | TL=1 | X |

### 疏漏

* 由於它不精確（受到常數影響），尤其當常數特別大或小時，用它來判斷 TLE 便很可能出錯
* 有些題目不易計算時間複雜度（尤其是暴搜剪枝題），隨意地計算複雜度**上限**很可能會高估題目難度
* 受系統影響，對於特別快和慢的系統可能要調整判斷 TLE 的臨界值

### 如何找出最高階項

最高階項就是成長率最大的項  
最基本的分類：指數 &gt; 多項式

可以代數字去比較，或是畫圖，甚至數學好的話可以利用微積分算成長率推估。

| 名稱 | 執行時間 |
| :--- | :--- |
| 常數時間 | $$O(1)$$  |
| 對數時間 | $$O(logn)$$ |
| 根號時間 | $$O(\sqrt n)$$  |
| 線性時間 | $$O(n)$$ |
| 線性對數時間 | $$O(nlogn)$$ |
| 二次時間 | $$O(n^2)$$ |
| 三次時間 | $$O(n^3)$$ |
| 指數時間 | $$O(2^n)$$ |
| 階乘時間 | $$O(n!)$$ |

\*\*\*\*

![&#x756B;&#x5716;&#x6BD4;&#x8F03;&#xFF0C;&#x4F86;&#x6E90;&#xFF1A;&#x7DAD;&#x57FA;&#x767E;&#x79D1;](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/1024px-Comparison_computational_complexity.svg.png)

#### 幾個常見的級數 <a id="&#x5E7E;&#x500B;&#x5E38;&#x898B;&#x7684;&#x7D1A;&#x6578;"></a>

* $$ 1+2+3+4+...+n=O(n^2)$$
* $$n+\frac{n}{2}+\frac{n}{4}+\frac{n}{8}+\frac{n}{16}+...=O(n)$$   
* $$\log1+\log2+\log3+...+\log n=\log(n!)=O(n\log n)$$  

## 空間複雜度

概念與時間複雜度類似，計算大約會花多少記憶體，但由於大多題目不會卡空間所以通常不用管這個  
而且除非使用大量函數，例如遞迴函數，或者奇怪的資料結構，否則空間通常很容易精確計算，  
主要用途是表達方便，例如用於表示演算法的空間需求

## 總結

#### 養成習慣在開始寫程式前，先計算時間複雜度以判斷你的做法是否會 TLE <a id="&#x990A;&#x6210;&#x7FD2;&#x6163;&#x5728;&#x958B;&#x59CB;&#x5BEB;&#x7A0B;&#x5F0F;&#x524D;&#xFF0C;&#x5148;&#x8A08;&#x7B97;&#x6642;&#x9593;&#x8907;&#x96DC;&#x5EA6;&#x4EE5;&#x5224;&#x65B7;&#x4F60;&#x7684;&#x505A;&#x6CD5;&#x662F;&#x5426;&#x6703;TLE"></a>



